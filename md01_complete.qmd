---
title: "Exam Preparation" 
author: "Ana Bendiek Laranjo" 
date: today 
format:    
  html:
    embed-resources: true    
    toc: true     
    code-fold: true   
  pdf: default 
editor: visual
editor_options: 
  chunk_output_type: console
---

# Module 01: Hello

## Introduction

### Data

Data can be imported from many different sources. In this exercise, we import data from:

1.  an R Package that is loaded via the `library()` function.

```{r}
library(ggplot2)
library(dplyr)
library(gapminder)
library(gt)
```

### Gapminder data

For this analysis we'll use the Gapminder dataset from the gapminder R package.

```{r}
head(gapminder)
```

### Population

The table below shows a summary for the population grouped by continent.

```{r}
#| label: gapminder-lifexp  

gapminder |>    
  filter(year == 2007) |>    
  group_by(continent) |>   
  summarise(     
    mean_life_exp = mean(pop)   
    ) |>    
  gt()  
```

### Life expectancy

```{r}
#| label: boxplot-continent
#| fig-width: 5
#| fig-asp: 0.618

gapminder_2007 <- gapminder |> 
  filter(year == 2007)

ggplot(data = gapminder_2007, 
       mapping = aes(x = continent, 
                     y = lifeExp)) +
  geom_boxplot() +
  geom_jitter(width = 0.1, alpha = 1/4, size = 3) +
  labs(x = NULL,
       y = "life expectancy") +
  theme_minimal() 
```

# Module 02a: Data visualization with ggplot2

## Import

```{r}
library(ggplot2)
library(ggthemes)
library(ggridges)
library(palmerpenguins)
```

## Explore

```{r}
head(penguins)
str(penguins)
```

## Visualize with ggplot2

### Functions and arguments

-   functions: ggplot(), aes(), geom_point()
-   arguments: data, mapping, color

```{r}
ggplot(data = penguins,
       mapping = aes(x = flipper_length_mm, 
                     y = body_mass_g)) +
  geom_point()
```

### Aesthetic mappings

-   options: x, y, color, shape, size, alpha

```{r}
ggplot(data = penguins,
       mapping = aes(x = flipper_length_mm, 
                     y = body_mass_g, 
                     color = species,
                     shape = species)) +
  geom_point()
```

### Settings

```{r}
ggplot(data = penguins,
       mapping = aes(x = flipper_length_mm, 
                     y = body_mass_g, 
                     color = species,
                     shape = species)) +
  geom_point(size = 5, alpha = 0.7)
```

### Color scales

```{r}

ggplot(data = penguins,
       mapping = aes(x = flipper_length_mm, 
                     y = body_mass_g, 
                     color = species,
                     shape = species)) +
  geom_point(size = 5, alpha = 0.7) +
  scale_color_colorblind() 

```

```{r}

ggplot(data = penguins,
       mapping = aes(x = flipper_length_mm, 
                     y = body_mass_g, 
                     color = species,
                     shape = species)) +
  geom_point(size = 5, alpha = 0.7) +
  scale_color_manual(values = c("red", "blue", "green")) 

```

### Facets

Keyboard shortcut for the tilde (\~) varies by keyboard layout:

-   US keyboard Windows/Mac: Shift + \` (top left of your keyboard next to the 1)
-   UK keyboard Windows/Mac: Shift + \# (bottom right of your keyboard, next to Enter)
-   CH keyboard Windows/Max: Alt/Option + -

```{r}
ggplot(data = penguins,
       mapping = aes(x = flipper_length_mm,
                     y = body_mass_g)) +
  geom_point() +
  facet_grid(species ~ island)
```

```{r}
ggplot(data = penguins,
       mapping = aes(x = flipper_length_mm,
                     y = body_mass_g)) +
  geom_point() +
  facet_wrap(~species)
```

### Themes

Some code in this section is already prepared, we will add more code together.

```{r}

ggplot(data = penguins,
       mapping = aes(x = flipper_length_mm, 
                     y = body_mass_g, 
                     color = species,
                     shape = species)) +
  geom_point(size = 5, alpha = 0.7) +
  scale_color_colorblind() +
  theme_minimal()

```

## Visualizing distributions

### Categorical variables

```{r}
ggplot(data = penguins,
       mapping = aes(x = species)) +
  geom_bar()
```

```{r}
ggplot(data = penguins,
       mapping = aes(x = species,
                     fill = island)) +
  geom_bar()
```

### Numerical continuous variables

The code in this section is already prepared, we will run through the code chunks together.

```{r}
ggplot(data = penguins,
       mapping = aes(x = body_mass_g)) +
  geom_histogram()
```

```{r}
ggplot(data = penguins,
       mapping = aes(x = body_mass_g,
                     fill = species)) +
  geom_histogram()
```

```{r}
ggplot(data = penguins,
       mapping = aes(x = body_mass_g,
                     fill = species)) +
  geom_density()
```

```{r}
ggplot(data = penguins,
       mapping = aes(x = body_mass_g,
                     y = species,
                     fill = species)) +
  geom_density_ridges()
```

# Module 02b: Working with R

## Import

```{r}
library(ggplot2)
library(dplyr)
library(gapminder)
```

## Explore

```{r}
head(gapminder)
tail(gapminder)
glimpse(gapminder)
str(gapminder)
nrow(gapminder)
ncol(gapminder)
```

## Transform - Narrow down

```{r}
gapminder_2007 <- gapminder |> 
  filter(year == 2007)
```

-   Keyboard shortcut for pipe operator: Ctrl / Cmd + Shift + M
-   Keyboard shortcut for assignment operator: Alt + -

## Visualize

```{r}
#| eval: true
ggplot(data = gapminder_2007,
       mapping = aes(x = continent,
                     y = lifeExp)) +
  geom_boxplot()
```
# Module 02: Make a plot

## Task 1: Import

The required packages for this homework exercise have already been added.

1.  Run the code chunk with the label 'load-packages' to load the required packages. Tipp: Click on the green play button in the top right corner of the code chunk.

```{r}
library(gapminder)
library(ggplot2)
library(dplyr)
```

## Task 2: Transform for data in 2007

Below is a typical task description as you will find them in the homework assignments. For "Fill in the gaps" tasks, you should replace the underscores \_\_\_ with the described code and then change the value of the code block option from false to true. In other tasks, you will create your own code from scratch. Over time, the task descriptions will be become less detailed.

**Fill in the gaps**

1.  A code chunk has already been created below.

2.  Start with the `gapminder` object and add the pipe operator at the end of the line.

3.  On a new line use the `filter()` function to narrow down the data for observation of the year 2007.

4.  Use the assignment operator to assign the data to an object named `gapminder_2007`.

5.  Run the code contained in the code chunk and fix any errors.

6.  Next to the code chunk option `#| eval:` change the value from `false` to `true`.

7.  Render the document and fix any errors.

```{r}
#| eval: true
 
gapminder_2007 <- gapminder |> 
  filter(year == 2007) 
```

## Task 3: Create a boxplot

This is a typical task without any starter code.

1.  Add a new code chunk below point 5.

2.  Use the `ggplot()` function and the `gapminder_2007` object to create a boxplot with the following aesthetic mappings:

-   continent to the x-axis;
-   life expectancy to the y-axis;
-   continent to color using the `fill = continent` argument inside `aes()`

3.  Run the code contained in the code chunk and fix any errors.

4.  What are the data types of the three variables used for aesthetic mappings?

```{r}
ggplot(data = gapminder_2007,
       mapping = aes(x = continent,
                     y = lifeExp,
                     fill = continent)) +
  geom_boxplot()
```

# Module 03a: Data transformation with dplyr

```{r}
library(readr)
library(dplyr)
```

## Import

In this exercise we use data of the UNICEF/WHO Joint Monitoring Programme (JMP) for Water Supply, Sanitation and Hygiene (WASH). The data is available at <https://washdata.org/data> and published as an R data package at <https://github.com/WASHNote/jmpwashdata/>.

The data set is available in the `data` folder as a CSV file named `jmp_wld_sanitation_long.csv`.

The data set contains the following variables:

-   `name`: country name
-   `iso3`: ISO3 country code
-   `year`: year of observation
-   `region_sdg`: SDG region
-   `residence`: residence type (national, rural, urban)
-   `varname_short`: short variable name (JMP naming convention)
-   `varname_long`: long variable name (JMP naming convention)

We use the `read_csv()` function to import the data set into R.

```{r}
sanitation <- read_csv("data/jmp_wld_sanitation_long.csv")

```

## Explore

```{r}
sanitation
glimpse(sanitation)
```

## Transform with dplyr

The `dplyr` R Package aims to provide a function for each basic verb of data manipulation. These verbs can be organised into three categories based on the component of the dataset that they work with:

-   Rows
-   Columns
-   Groups of rows

### filter()

The function `filter()` chooses rows based on column values. To use filtering effectively, you have to know how to select the observations that you want using the comparison operators. R provides the standard suite: \>, \>=, \<, \<=, != (not equal), and == (equal).

```{r}

sanitation |> 
  filter(residence == "national")

sanitation |> 
  filter(residence != "national")

sanitation |> 
  filter(residence == "national", iso3 == "SEN") 

sanitation |> 
  filter(iso3 == "UGA" | iso3 == "PER" | iso3 == "IND") 

sanitation |> 
  filter(iso3 %in% c("UGA", "PER", "IND"))

sanitation |> 
  filter(percent > 80)

sanitation |> 
  filter(percent <= 5)

sanitation |> 
  filter(is.na(percent))

sanitation |> 
  filter(!is.na(percent))

```

-   Keyboard shortcut for vertical bar \| (OR) in US/CH is: Shift + / (Windows) and Option + / (Mac)
-   Keyboard shortcut for vertical bar \| (OR) in UK: It's complitcated
-   Keyboard shortcut for pipe operator: Ctrl / Cmd + Shift + M
-   Keyboard shortcut for assignment operator: Alt + -

**Storing a resulting data frame as a new object**

```{r}
sanitation_national_2020_sm <- sanitation |> 
  filter(residence == "national",
         year == 2020,
         varname_short == "san_sm")
```

### arrange()

The function `arrange()` changes the order of the rows.

```{r}

sanitation_national_2020_sm |> 
  arrange(percent)

sanitation_national_2020_sm |> 
  arrange(desc(percent))

```

### select()

The `select()` function chooses columns based on their names.

```{r}
sanitation_national_2020_sm |> 
  select(name, percent)

sanitation_national_2020_sm |> 
  select(-varname_short)

sanitation_national_2020_sm |> 
  select(name:region_sdg, percent)
```

### rename()

The `rename()` function changes the names of variables.

```{r}
sanitation |> 
  rename(country = name)
```

### mutate()

The `mutate()` function adds new variables based on existing variables or external data.

```{r}
sanitation |> 
  mutate(prop = percent / 100)

sanitation |> 
  mutate(id = seq(1:n()))
```

### relocate()

```{r}
sanitation |> 
  mutate(id = 1:n()) |> 
  relocate(id)

sanitation |> 
  mutate(id = 1:n()) |> 
  relocate(id, .before = name)

```

### summarise()

The `summarise()` function reduces multiple values down to a single summary.

```{r}

sanitation_national_2020_sm |> 
  summarise()

sanitation_national_2020_sm |> 
  summarise(mean_percent = mean(percent))

sanitation_national_2020_sm |> 
  summarise(mean_percent = mean(percent, na.rm = TRUE))

sanitation_national_2020_sm |> 
  summarise(n = n(),
            mean_percent = mean(percent, na.rm = TRUE))

sanitation_national_2020_sm |> 
  filter(!is.na(percent)) |> 
  summarise(n = n(),
            mean_percent = mean(percent),
            sd_percent = sd(percent))
```

### group_by()

The `group_by()` function is used to group the data by one or more variables.

```{r}

sanitation_national_2020_sm |> 
  group_by(region_sdg)

sanitation_national_2020_sm |> 
  group_by(region_sdg) |> 
  summarise(n = n(),
            mean_percent = mean(percent),
            sd_percent = sd(percent))

sanitation_national_2020_sm |> 
  filter(!is.na(percent)) |> 
  group_by(region_sdg) |> 
  summarise(n = n(),
            mean_percent = mean(percent),
            sd_percent = sd(percent))
```

### count()

The `count()` function is a convenient wrapper for `group_by()` and `summarise(n = n())`. You can prepare frequency tables with `count()`.

```{r}

sanitation |> 
  count(region_sdg)

sanitation |> 
  count(varname_short)

sanitation |> 
  count(varname_long)

sanitation |> 
  count(varname_short, varname_long)

```


#Module 03b: Filter function

```{r}
library(readr)
library(dplyr)
library(ggplot2)
library(ggthemes)
```

## Import

In this exercise we use data of the UNICEF/WHO Joint Monitoring Programme (JMP) for Water Supply, Sanitation and Hygiene (WASH). The data is available at <https://washdata.org/data> and published as an R data package at <https://github.com/WASHNote/jmpwashdata/>.

The data set `jmp_wld_sanitation_long` is available in the `data` folder of this repository. The data set is in long format and contains the following variables:

-   `name`: country name
-   `iso3`: ISO3 country code
-   `year`: year of observation
-   `region_sdg`: SDG region
-   `residence`: residence type (national, rural, urban)
-   `varname_short`: short variable name (JMP naming convention)
-   `varname_long`: long variable name (JMP naming convention)

We use the `read_csv()` function to import the data set into R.

```{r}
sanitation <- read_csv("data/jmp_wld_sanitation_long.csv")
```

## Transform

### Task 1.1

1.  Run all code chunks above.
2.  Use the `filter()` function to create a subset from the `sanitation` data containing national estimates for the year 2020.
3.  Store the result as a new object in your environment with the name `sanitation_national_2020`

```{r}
sanitation_national_2020 <- sanitation |> 
  filter(residence == "national", year == 2020)
```

### Task 1.2

1.  Use the `filter()` function to create a subset from the `sanitation` data containing urban and rural estimates for Nigeria.
2.  Store the result as a new object in your environment with the name `sanitation_nigeria_urban_rural`

```{r}
sanitation_nigeria_urban_rural <- sanitation |> 
  filter(name == "Nigeria", residence != "national")
```

### Task 1.3 (stretch goal)

1.  Use the `ggplot()` function to create a connected scatterplot with `geom_point()` and `geom_line()` for the data you created in Task 1.2.

2.  Use the `aes()` function to map the year variable to the x-axis, the `percent` variable to the y-axis, and the `varname_short` variable to color and group aesthetic.

3.  Use `facet_wrap()` to create a separate plot urban and rural populations.

4.  Change the colors using `scale_color_colorblind()`.

```{r}
ggplot(data = sanitation_nigeria_urban_rural,
       mapping = aes(x = year, 
                     y = percent, 
                     group = varname_short, 
                     color = varname_short)) +
  geom_point() +
  geom_line() +
  facet_wrap(~residence) +
  scale_color_colorblind() 

```

# Module 03c: Summary data transformation

```{r}
library(readr)
library(dplyr)
```

## Import

In this exercise we use data of the UNICEF/WHO Joint Monitoring Programme (JMP) for Water Supply, Sanitation and Hygiene (WASH). The data is available at <https://washdata.org/data> and published as an R data package at <https://github.com/WASHNote/jmpwashdata/>.

The data set `jmp_wld_sanitation_long` is available in the `data` folder of this repository. The data set is in long format and contains the following variables:

-   `name`: country name
-   `iso3`: ISO3 country code
-   `year`: year of observation
-   `region_sdg`: SDG region
-   `residence`: residence type (national, rural, urban)
-   `varname_short`: short variable name (JMP naming convention)
-   `varname_long`: long variable name (JMP naming convention)

We use the `read_csv()` function to import the data set into R.

```{r}
sanitation <- read_csv("data/jmp_wld_sanitation_long.csv")
```

### Task 1.1

1.  Run all code chunks above.
2.  Use the `glimpse()` function to get an overview of the data set.
3.  How many variables are in the data set?

```{r}
glimpse(sanitation)
```

## Transform

### Task 2.1

1.  Use the `count()` function to identify how many SDG regions are included in the data set.
2.  How many SDG regions are in the data set?

```{r}
sanitation |> 
  count(region_sdg)
```

### Task 2.2

1.  Use the `count()` function to identify the levels in the varname_short and varname_long variables.
2.  Which indicator in varname_long does san_od refer to?

```{r}
sanitation |> 
  count(varname_short, varname_long)
```

### Task 2.3

1.  Use the `filter()` function to create a subset from the `sanitation` data containing national estimates for people with "no sanitation facilities" for the year 2020.

2.  Store the result as a new object in your environment with the name `sanitation_national_2020_od`.

```{r}
sanitation_national_2020_od <- sanitation |> 
  filter(residence == "national", 
         year == 2020,
         varname_short == "san_od")

```

### Task 2.4

1.  Use the `sanitation_national_2020_od` data and the `count()` function to identify the number of countries with 0% for the indicator "no sanitation facilities" in 2020.

```{r}
sanitation_national_2020_od |> 
  count(percent)
```

### Task 2.5

1.  How many countries in `sanitation_national_2020_od` data had no estimate for "no sanitation facilities" in 2020? Tipp: A country without an estimate has `NA` for the percent variable.

```{r}
sanitation_national_2020_od |> 
  filter(is.na(percent))
```

### Task 2.6

1.  Use the `sanitation_national_2020_od` data in combination with `group_by()` and `summarise()` functions to calculate the mean, standard deviation and number of countries for the indicator "no sanitation facilities" in 2020.

2.  How did you treat the missing values for the percent variable in the calculation?

```{r}

sanitation_national_2020_od |> 
  filter(!is.na(percent)) |>
  group_by(region_sdg) |> 
  summarise(
    mean = mean(percent, na.rm = TRUE),
    sd = sd(percent, na.rm = TRUE),
    n = n()
  )
```

# Module 04a: Factors

```{r}
library(ggplot2)
library(dplyr)
library(readr)
library(ggthemes)
```

## Import

```{r}
waste <- read_csv("data/processed/waste-city-level-sml.csv") 
```

## Explore

1.  Run all code chunks above.

2.  Use the `glimpse()` function to inspect the `waste` object.

3.  What does the data cover? Briefly discuss with your room partner.

```{r}
glimpse(waste)
```

1.  Use the `count()` function for the `waste` object to count the number of rows for each value of the `income_id` variable.

2.  What do the four values of the `income_id` variable represent?

```{r}
waste |> 
  count(income_id)
```

## Transform

1.  Use the `c()` function to create a vector with the following values: "HIC", "UMC", "LMC", "LIC".
2.  Use the assignment operator (`<-`) to store the resulting vector as a new object called `levels_income`.

```{r}
levels_income <- c("HIC", "UMC", "LMC", "LIC")
```

1.  Use the `mutate()` function to convert the `income_id` variable to a factor variable with the levels specified in the `levels_income` object.

2.  Use the assignment operator (`<-`) to store the resulting data as a new object called `waste_lvl`.

```{r}
waste_lvl <- waste |> 
  mutate(income_id = factor(income_id, levels = levels_income))
```

1.  Use the `count()` function to verify that the `income_id` variable is now a factor variable with the correct levels.

```{r}
waste_lvl |> 
  count(income_id)
```

1.  Starting with `waste_lvl`, use the `mutate()` function to create a new variable called `generation_kg_capita` that contains the `generation_tons_year` variable divided by the `population` variable and multiplied with 1000.

2.  Use the assignment operator (`<-`) to store the resulting data as a new object called `waste_capita`.

```{r}
waste_capita <- waste_lvl |> 
  mutate(generation_kg_capita = generation_tons_year / population * 1000) 
```

## Visualize

1.  Next to the code chunk option `#| eval:` change the value from false to true.

2.  Run the code in the code-chunk below to create a boxplot of the `generation_kg_capita` variable by `income_id`.

3.  What do you observe? Discuss with your room partner.

```{r}
#| eval: true
ggplot(data = waste_capita,
       mapping = aes(x = income_id, 
                     y = generation_kg_capita, 
                     color = income_id)) +
  geom_boxplot(outlier.fill = NA) +
  geom_jitter(width = 0.1, alpha = 0.3) +
  scale_color_colorblind() +
  labs(x = "Income group",
       y = "Waste generation (tons per capita per year)")

```

# Module 04b: Data import

```{r}
library(readr)
library(readxl)
library(dplyr)
```

## Import

## Task 1: Import waste data as CSV

1.  Run all code chunks above.
2.  Use the `read_csv()` function to import the `waste-city-level.csv` file from the `data/raw` folder.
3.  Assign the resulting data to an object called `waste`.

```{r}
waste <- read_csv("data/raw/waste-city-level.csv")
```

## Task 2: Import JMP data as CSV

1.  Use the `read_csv()` function to import the `jmp_wld_sanitation_long.csv` file from the `data/processed` folder.
2.  Assign the resulting data to an object called `san_csv`.

```{r}
san_csv <- read_csv("data/processed/jmp_wld_sanitation_long.csv")
```

## Task 3: Import JMP data as RDS

1.  Use the `read_rds()` function to import the `jmp_wld_sanitation_long.rds` file from the `data/processed` folder.
2.  Assign the resulting data to an object called `san_rds`.

```{r}
san_rds <- read_rds("data/processed/jmp_wld_sanitation_long.rds")
```

## Task 4: Compare CSV and RDS

1.  Use the `glimpse()` function to inspect the `san_csv` and `san_rds` objects.
2.  What is the difference between the two objects? Discuss with your room partner.

```{r}
glimpse(san_csv)
glimpse(san_rds)
```

## Task 5: Use LLM for an explanation

1.  Open <https://www.perplexity.ai/> in your browser and enter the following prompt:

You are an experienced educator in teaching R to novice users without prior knowledge. Explain what the .rds format is and how it differs from the .csv file format. Avoid technical language.

2.  Read the answer and ask the tool questions for clarification of something is unclear.

3.  Share a link to your conversation here (see screenshot below):

### Screenshot

![](images/perplexity-share-conversation-link.png)

---
#Module 05:Conditions

```{r}
library(tidyverse)
library(ggthemes)
```

## Import

We continue to work with a subset of the "What a Waste" database.

```{r}
waste <- read_csv("data/processed/waste-city-level-sml.csv")
```

We will also use an example spreadsheet that was created by one of the course participants.

```{r}
solids <- readxl::read_excel("data/raw/TS_poo_2022.xlsx")
```

## Explore

```{r}
glimpse(waste)
```

```{r}
waste |> 
    count(income_id)
```

## Transform

Conditional statements with mutate() & case_when() of dplyr R package

### waste data

```{r}
#| eval: false

waste_cat <- waste |> 
    mutate(generation_kg_capita = generation_tons_year / population * 1000) |> 
    mutate(income_cat = case_when(
        income_id == "HIC" ~ "high income",
        income_id == "UMC" ~ "upper-middle income",
        income_id == "LMC" ~ "lower-middle income",
        income_id == "LIC" ~ "low income"
    ))


levels_income <- c("HIC", "UMC", "LMC", "LIC")

levels_income_cat <- c("high income", 
                       "upper-middle income",
                       "lower-middle income",
                       "low income")

waste_fct <- waste_cat |>
    mutate(income_id = factor(income_id, levels = levels_income)) |> 
    mutate(income_cat = factor(income_cat, levels = levels_income_cat)) |> 
    relocate(income_cat, .after = income_id)

```

```{r}
write_rds(x = waste_fct, file = "data/processed/waste-city-level-sml.rds")
```

### Faecal sludge solids data

```{r}
solids |> 
    mutate(total_solids_gL = case_when(
        source_type == "septic tank" ~ total_solids_gL * 100,
        .default = total_solids_gL
    ))
```

## Visualize

### Categories as character

```{r}
#| eval: true
ggplot(data = waste_cat,
       mapping = aes(x = income_cat, 
                     y = generation_kg_capita, 
                     color = income_cat)) +
    geom_boxplot(outlier.shape = NA) +
    geom_jitter(size = 3, width = 0.1, alpha = 0.3) +
    scale_color_colorblind() +
    labs(x = "Income group",
         y = "Waste generation (tons per capita per year)") 
```

### Categories as factor

```{r}

#| eval: true
ggplot(data = waste_fct,
       mapping = aes(x = income_cat, 
                     y = generation_kg_capita, 
                     color = income_cat)) +
    geom_boxplot(outlier.shape = NA) +
    geom_jitter(size = 3, width = 0.1, alpha = 0.3) +
    scale_color_colorblind() +
    labs(x = "Income group",
         y = "Waste generation (tons per capita per year)") 
```

#Module 05a: Mutate()

```{r}
library(tidyverse)
library(readxl)
```

## Import

We are using another faecal sludge solids example dataset

```{r}
sludge <- read_xlsx("data/raw/faecal-sludge-analysis.xlsx")
```

## Task 1

1.  A mistake happened during data entry for sample id 16. Use `mutate()` and `case_when()` to change the ts value of 0.72 to 8.72.

```{r}
sludge |> 
    mutate(ts = case_when(
        ts ==  0.72 ~ 8.72,
        .default = ts
    ))

```

## Task 2

1.  Another mistake happened during data entry for sample id 6. Use `mutate()` and `case_when()` to change the system value of id 6 from "pit latrine" to "septic tank".

```{r}
sludge |> 
    mutate(system = case_when(
        id ==  6 ~ "septic tank",
        .default = system
    ))

```

## Task 3 (stretch goal)

1.  Add a new variable with the name `ts_cat` to the data frame that categorizes sludge samples into low, medium and high solids content.Use `mutate()` and `case_when()` to create the new variable.

-   samples with less than 15 g/L are categorized as low
-   samples with 15 g/L to 50 g/L are categorized as medium
-   samples with more than 50 g/L are categorized as high

```{r}

sludge |> 
    mutate(ts_cat = case_when(
        ts < 15 ~ "low",
        ts >= 15 & ts <= 50 ~ "medium",
        ts > 50 ~ "high"
    ))
```

#Module 05b: Dates

```{r}
library(tidyverse)
library(readxl)
```

## Dates

```{r}

dates <- read_excel("data/raw/date-formats.xlsx")

```

In R and other programming languages, dates are stored as numbers. The number of days since 1970-01-01 is the ISO 8601 standard.

In Excel, dates are stored as numbers of days since 1900-01-01. In Excel, the date number 1 corresponds to "1900-01-01," but this system incorrectly considers 1900 as a leap year, which it is not. As a result, to correctly interpret date numbers that originate from systems like Excel, the origin "1899-12-30" is used to account for this discrepancy

```{r}
dates_class <- dates |> 
    mutate(date_iso = as_date(date_iso)) |> 
    mutate(date_us = mdy(date_us)) |> 
    mutate(date_eu = dmy(date_eu)) |> 
    mutate(date_num = as_date(date_num, origin = "1899-12-30")) |> 
    mutate(date = as_date(date_time)) |> 
    mutate(date_time_tz = with_tz(date_time, tzone = "Africa/Kampala")) |>
    mutate(today = today())

OlsonNames()
```

```{r}
as.numeric(today())
as_date(1)
```

```{r}
dates_class |> 
    select(today) |> 
    mutate(year = year(today)) |>
    mutate(month = month(today, label = TRUE, abbr = FALSE, locale = "fr_FR")) |> 
    mutate(quarter = quarter(today)) |>
    mutate(week = week(today)) |>
    mutate(day = day(today)) |>
    mutate(day_of_week = wday(today, label = TRUE, abbr = FALSE, locale = "fr_FR")) |>
    mutate(day_of_year = yday(today)) |>
    mutate(week_of_year = week(today)) 


```

#Module 05c: Tables

```{r}
library(tidyverse)
library(gt)
library(gtsummary)
library(knitr)
library(DT)
```

## Import

We continue to work with a subset of the "What a Waste" database.

```{r}
waste_gt <- read_rds("data/processed/waste-city-level-sml.rds")
```

## Transform

```{r}
waste_tbl_income <- waste_gt |> 
    filter(!is.na(generation_kg_capita))  |> 
    group_by(income_cat) |> 
    summarise(
        count = n(),
        mean = mean(generation_kg_capita),
        sd = sd(generation_kg_capita),
        median = median(generation_kg_capita),
        min = min(generation_kg_capita),
        max = max(generation_kg_capita)
    )
```

## Table

```{r}
waste_tbl_income
```

```{r}
waste_tbl_income |> 
    gt() |> 
    tab_header(title = "Waste generation per capita (kg/year) by income group",
               subtitle = "Data from 326 cities") |>
    fmt_number(columns = count:max, decimals = 0) |> 
    cols_label(income_cat = "income category")
```

@tbl-waste-income highlights that cities in countries classfied as high income countries generate more waste per capita than cities in lower income countries.

```{r}
#| label: tbl-waste-income
#| tbl-cap: "Waste generation per capita (kg/year) by income group. Data from 326 cities."
waste_tbl_income |> 
    rename(`income category` = income_cat) |>
    kable(digits = 0)
```

